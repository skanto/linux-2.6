/*
 * Omnivision ov9655 Camera driver
 *
 * Copyright (C) 2006 Atmel Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#define DEBUG			12
#define VERBOSE			12
#define VERBOSE_DEBUG		12
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/err.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>

#include <media/atmel-isi.h>
#include "ov9655.h"


static unsigned short normal_i2c[] = {
	OV9655_I2C_ADDR,
	I2C_CLIENT_END
};
I2C_CLIENT_INSMOD;

static char mclk_name[32] = "isi_clk";
module_param_string(mclk, mclk_name, sizeof(mclk_name), 0644);
MODULE_PARM_DESC(mclk, "Name of the clock used as camera clock input");
MODULE_PARM_DESC(mclk, "Name of mclk parent clock");

struct ov9655 {
	struct mutex		mutex;
	u8			miscel_ctrl;
	u16			pll_avr_ctrl;
	struct clk		*mclk;
	struct i2c_client	client;
	struct atmel_isi_camera	cam;
};
#define to_ov9655(cam) container_of(cam, struct ov9655, cam)

/*
 * OV9655 register configuration for all combinations of pixel format and
 * image size(for the moment only qvga YUV...)
 */
/* YUV configs */
const static struct ov9655_reg qqcif_yuv[] = { };
const static struct ov9655_reg qqvga_yuv[] = { };
const static struct ov9655_reg sqcif_yuv[] = { 
	{ 0x12, 0x80 }, { 0x00, 0x00 }, { 0x01, 0x80 },
	{ 0x02, 0x80 }, { 0x03, 0x12 }, { 0x04, 0x03 },
	{ 0x0e, 0x61 }, { 0x0f, 0x42 }, { 0x11, 0x01 },
	{ 0x12, 0x62 }, { 0x13, 0xe7 }, { 0x14, 0x3a },
	{ 0x16, 0x24 }, { 0x17, 0x18 }, { 0x18, 0x0c },
	{ 0x19, 0x01 }, { 0x1a, 0x81 }, { 0x1e, 0x04 },
	{ 0x24, 0x3c }, { 0x25, 0x36 }, { 0x26, 0x72 },
	{ 0x27, 0x08 }, { 0x28, 0x08 }, { 0x29, 0x15 },
	{ 0x2a, 0x00 }, { 0x2b, 0x00 }, { 0x2c, 0x08 },
	{ 0x32, 0xa4 }, { 0x33, 0x00 }, { 0x34, 0x3f },
	{ 0x35, 0x00 }, { 0x36, 0x3a }, { 0x38, 0x72 },
	{ 0x39, 0x57 }, { 0x3a, 0x00 }, { 0x3b, 0x04 }, 
	{ 0x3d, 0x99 }, { 0x3e, 0x0e }, { 0x3f, 0xc1 }, 
	{ 0x40, 0xc0 }, { 0x41, 0x01 }, { 0x42, 0xc0 }, 
	{ 0x43, 0x0a }, { 0x44, 0xf0 }, { 0x45, 0x46 },
	{ 0x46, 0x62 }, { 0x47, 0x2a }, { 0x48, 0x3c }, 
	{ 0x4a, 0xfc }, { 0x4b, 0xfc }, { 0x4c, 0x7f }, 
	{ 0x4d, 0x7f }, { 0x4e, 0x7f },

	{ 0x52, 0x28 }, { 0x53, 0x88 }, { 0x54, 0xb0 },
	{ 0x4f, 0x98 }, { 0x50, 0x98 }, { 0x51, 0x00 }, 
	{ 0x58, 0x1a }, 


	{ 0x5b, 0x64 },
	{ 0x5c, 0x84 }, { 0x5d, 0x53 }, { 0x5e, 0x0e }, 
	{ 0x5f, 0xf0 }, { 0x60, 0xf0 }, { 0x61, 0xf0 }, 
	{ 0x62, 0x00 }, { 0x63, 0x00 }, { 0x64, 0x02 }, 
	{ 0x65, 0x20 }, { 0x66, 0x00 }, { 0x69, 0x0a }, 

	{ 0x6b, 0x5a }, { 0x6c, 0x04 }, { 0x6d, 0x55 },
	{ 0x6e, 0x00 }, { 0x6f, 0x9d }, { 0x70, 0x21 }, 
	{ 0x71, 0x78 }, { 0x72, 0x11 }, { 0x73, 0x02 }, 
	{ 0x74, 0x3a }, { 0x75, 0x35 }, { 0x76, 0x01 },
	{ 0x77, 0x02 },
	
	{ 0x7a, 0x12 }, { 0x7b, 0x08 }, { 0x7c, 0x15 },
	{ 0x7d, 0x24 }, { 0x7e, 0x45 }, { 0x7f, 0x55 },
	{ 0x80, 0x6a }, { 0x81, 0x78 }, { 0x82, 0x87 },
	{ 0x83, 0x96 }, { 0x84, 0xa3 }, { 0x85, 0xb4 },
	{ 0x86, 0xc3 }, { 0x87, 0xd6 }, { 0x88, 0xe6 },
	{ 0x89, 0xf2 },
	
	{ 0x8a, 0x24 }, { 0x8c, 0x80 }, { 0x90, 0x7d },
	{ 0x91, 0x7b }, { 0x9d, 0x02 }, { 0x9e, 0x02 },
	{ 0x9f, 0x7a }, { 0xa0, 0x79 }, { 0xa1, 0x40 },
	{ 0xa4, 0x50 }, { 0xa5, 0x68 }, { 0xa6, 0x4a },
	{ 0xa8, 0xc1 }, { 0xa9, 0xef }, { 0xaa, 0x92 },
	{ 0xab, 0x04 }, { 0xac, 0x80 }, { 0xad, 0x80 },
	{ 0xae, 0x80 }, { 0xaf, 0x80 }, { 0xb2, 0xf2 },
	{ 0xb3, 0x20 }, { 0xb4, 0x20 }, { 0xb5, 0x00 },
	{ 0xb6, 0xaf }, { 0xbb, 0xae }, { 0xbc, 0x7f },
	{ 0xbd, 0x7f }, { 0xbe, 0x7f }, { 0xbf, 0x7f },
	{ 0xc0, 0xaa }, { 0xc1, 0xc0 }, { 0xc2, 0x01 },
	{ 0xc3, 0x4e }, { 0xc6, 0x05 }, { 0xc7, 0x82 },
	{ 0xc9, 0xe0 }, { 0xca, 0xe8 }, { 0xcb, 0xf0 },
	{ 0xcc, 0xd8 }, { 0xcd, 0x93 }, { 0xcd, 0x93 },
	
	{ OV9655_REG_TERM, OV9655_VAL_TERM }
};
const static struct ov9655_reg qcif_yuv[] = { 
	{ 0x12, 0x80 }, { 0x00, 0x00 }, { 0x01, 0x80 },
	{ 0x02, 0x80 }, { 0x03, 0x12 }, { 0x04, 0x03 },
	{ 0x0e, 0x61 }, { 0x0f, 0x42 }, { 0x11, 0x01 },
	{ 0x12, 0x62 }, { 0x13, 0xe7 }, { 0x14, 0x3a },
	{ 0x16, 0x24 }, { 0x17, 0x18 }, { 0x18, 0x0c },
	{ 0x19, 0x01 }, { 0x1a, 0x81 }, { 0x1e, 0x04 },
	{ 0x24, 0x3c }, { 0x25, 0x36 }, { 0x26, 0x72 },
	{ 0x27, 0x08 }, { 0x28, 0x08 }, { 0x29, 0x15 },
	{ 0x2a, 0x00 }, { 0x2b, 0x00 }, { 0x2c, 0x08 },
	{ 0x32, 0xa4 }, { 0x33, 0x00 }, { 0x34, 0x3f },
	{ 0x35, 0x00 }, { 0x36, 0x3a }, { 0x38, 0x72 },
	{ 0x39, 0x57 }, { 0x3a, 0x00 }, { 0x3b, 0x04 }, 
	{ 0x3d, 0x99 }, { 0x3e, 0x0e }, { 0x3f, 0xc1 }, 
	{ 0x40, 0xc0 }, { 0x41, 0x01 }, { 0x42, 0xc0 }, 
	{ 0x43, 0x0a }, { 0x44, 0xf0 }, { 0x45, 0x46 },
	{ 0x46, 0x62 }, { 0x47, 0x2a }, { 0x48, 0x3c }, 
	{ 0x4a, 0xfc }, { 0x4b, 0xfc }, { 0x4c, 0x7f }, 
	{ 0x4d, 0x7f }, { 0x4e, 0x7f },

	{ 0x52, 0x28 }, { 0x53, 0x88 }, { 0x54, 0xb0 },
	{ 0x4f, 0x98 }, { 0x50, 0x98 }, { 0x51, 0x00 }, 
	{ 0x58, 0x1a }, 


	{ 0x5b, 0x64 },
	{ 0x5c, 0x84 }, { 0x5d, 0x53 }, { 0x5e, 0x0e }, 
	{ 0x5f, 0xf0 }, { 0x60, 0xf0 }, { 0x61, 0xf0 }, 
	{ 0x62, 0x00 }, { 0x63, 0x00 }, { 0x64, 0x02 }, 
	{ 0x65, 0x20 }, { 0x66, 0x00 }, { 0x69, 0x0a }, 

	{ 0x6b, 0x5a }, { 0x6c, 0x04 }, { 0x6d, 0x55 },
	{ 0x6e, 0x00 }, { 0x6f, 0x9d }, { 0x70, 0x21 }, 
	{ 0x71, 0x78 }, { 0x72, 0x11 }, { 0x73, 0x02 }, 
	{ 0x74, 0x3a }, { 0x75, 0x35 }, { 0x76, 0x01 },
	{ 0x77, 0x02 },
	
	{ 0x7a, 0x12 }, { 0x7b, 0x08 }, { 0x7c, 0x15 },
	{ 0x7d, 0x24 }, { 0x7e, 0x45 }, { 0x7f, 0x55 },
	{ 0x80, 0x6a }, { 0x81, 0x78 }, { 0x82, 0x87 },
	{ 0x83, 0x96 }, { 0x84, 0xa3 }, { 0x85, 0xb4 },
	{ 0x86, 0xc3 }, { 0x87, 0xd6 }, { 0x88, 0xe6 },
	{ 0x89, 0xf2 },
	
	{ 0x8a, 0x24 }, { 0x8c, 0x80 }, { 0x90, 0x7d },
	{ 0x91, 0x7b }, { 0x9d, 0x02 }, { 0x9e, 0x02 },
	{ 0x9f, 0x7a }, { 0xa0, 0x79 }, { 0xa1, 0x40 },
	{ 0xa4, 0x50 }, { 0xa5, 0x68 }, { 0xa6, 0x4a },
	{ 0xa8, 0xc1 }, { 0xa9, 0xef }, { 0xaa, 0x92 },
	{ 0xab, 0x04 }, { 0xac, 0x80 }, { 0xad, 0x80 },
	{ 0xae, 0x80 }, { 0xaf, 0x80 }, { 0xb2, 0xf2 },
	{ 0xb3, 0x20 }, { 0xb4, 0x20 }, { 0xb5, 0x00 },
	{ 0xb6, 0xaf }, { 0xbb, 0xae }, { 0xbc, 0x7f },
	{ 0xbd, 0x7f }, { 0xbe, 0x7f }, { 0xbf, 0x7f },
	{ 0xc0, 0xaa }, { 0xc1, 0xc0 }, { 0xc2, 0x01 },
	{ 0xc3, 0x4e }, { 0xc6, 0x05 }, { 0xc7, 0x82 },
	{ 0xc9, 0xe0 }, { 0xca, 0xe8 }, { 0xcb, 0xf0 },
	{ 0xcc, 0xd8 }, { 0xcd, 0x93 }, { 0xcd, 0x93 },
	
	{ OV9655_REG_TERM, OV9655_VAL_TERM }
};
const static struct ov9655_reg qvga_yuv[] = {
	/* Value provided by Omnivision */
	{ 0x12, 0x80 }, { 0x00, 0x00 }, { 0x01, 0x80 },
	{ 0x02, 0x80 }, { 0x03, 0x02 }, { 0x04, 0x03 },
	{ 0x0e, 0x61 }, { 0x0f, 0x42 }, { 0x11, 0x01 },
	{ 0x12, 0x62 }, { 0x13, 0xe7 }, { 0x14, 0x3a },
	{ 0x16, 0x24 }, { 0x17, 0x18 }, { 0x18, 0x04 },
	{ 0x19, 0x01 }, { 0x1a, 0x81 }, { 0x1e, 0x04 },
	{ 0x24, 0x3c }, { 0x25, 0x36 }, { 0x26, 0x72 },
	{ 0x27, 0x08 },	{ 0x28, 0x08 }, { 0x29, 0x15 },
	{ 0x2a, 0x00 }, { 0x2b, 0x00 }, { 0x2c, 0x08 },
	{ 0x32, 0x24 }, { 0x33, 0x00 }, { 0x34, 0x3f },
	{ 0x35, 0x00 }, { 0x36, 0x3a }, { 0x38, 0x72 },
	{ 0x39, 0x57 }, { 0x3a, 0x00 }, { 0x3b, 0x04 },
	{ 0x3d, 0x99 }, { 0x3e, 0x0e }, { 0x3f, 0xc1 },
	{ 0x40, 0xc0 }, { 0x41, 0x01 }, { 0x42, 0xc0 },
	{ 0x43, 0x0a }, { 0x44, 0xf0 }, { 0x45, 0x46 },
	{ 0x46, 0x62 }, { 0x47, 0x2a }, { 0x48, 0x3c },
	{ 0x4a, 0xfc }, { 0x4b, 0xfc }, { 0x4c, 0x7f },
	{ 0x4d, 0x7f }, { 0x4e, 0x7f },

	{ 0x52, 0x28 }, { 0x53, 0x88 }, { 0x54, 0xb0 }, 
	{ 0x4f, 0x98 }, { 0x50, 0x98 }, { 0x51, 0x00 }, 
	{ 0x58, 0x1a }, 

	{ 0x59, 0x85 }, { 0x5a, 0xa9 }, { 0x5b, 0x64 },
	{ 0x5c, 0x84 }, { 0x5d, 0x53 }, { 0x5e, 0x0e },
	{ 0x5f, 0xf0 }, { 0x60, 0xf0 }, { 0x61, 0xf0 },
	{ 0x62, 0x00 }, { 0x63, 0x00 }, { 0x64, 0x02 },
	{ 0x65, 0x20 }, { 0x66, 0x00 }, { 0x69, 0x0a },
	{ 0x6b, 0x5a }, { 0x6c, 0x04 }, { 0x6d, 0x55 },
	{ 0x6e, 0x00 }, { 0x6f, 0x9d }, { 0x70, 0x21 },
	{ 0x71, 0x78 }, { 0x72, 0x11 }, { 0x73, 0x01 },
	{ 0x74, 0x10 }, { 0x75, 0x10 }, { 0x76, 0x01 },
	{ 0x77, 0x02 },

	{ 0x7a, 0x12 }, { 0x7b, 0x08 }, { 0x7c, 0x15 },
	{ 0x7d, 0x24 }, { 0x7e, 0x45 }, { 0x7f, 0x55 },
	{ 0x80, 0x6a }, { 0x81, 0x78 }, { 0x82, 0x87 },
	{ 0x83, 0x96 }, { 0x84, 0xa3 }, { 0x85, 0xb4 },
	{ 0x86, 0xc3 }, { 0x87, 0xd6 }, { 0x88, 0xe6 },
	{ 0x89, 0xf2 },

	{ 0x8a, 0x24 }, { 0x8c, 0x80 }, { 0x90, 0x7d },
	{ 0x91, 0x7b }, { 0x9d, 0x02 }, { 0x9e, 0x02 },
	{ 0x9f, 0x7a }, { 0xa0, 0x79 }, { 0xa1, 0x40 },
	{ 0xa4, 0x50 }, { 0xa5, 0x68 }, { 0xa6, 0x4a },
	{ 0xa8, 0xc1 }, { 0xa9, 0xef }, { 0xaa, 0x92 },
	{ 0xab, 0x04 }, { 0xac, 0x80 }, { 0xad, 0x80 },
	{ 0xae, 0x80 }, { 0xaf, 0x80 }, { 0xb2, 0xf2 },
	{ 0xb3, 0x20 }, { 0xb4, 0x20 }, { 0xb5, 0x00 },
	{ 0xb6, 0xaf }, { 0xbb, 0xae }, { 0xbc, 0x7f },
	{ 0xbd, 0x7f }, { 0xbe, 0x7f }, { 0xbf, 0x7f },
	{ 0xc0, 0xaa }, { 0xc1, 0xc0 }, { 0xc2, 0x01 },
	{ 0xc3, 0x4e }, { 0xc6, 0x05 }, { 0xc7, 0x81 },
	{ 0xc9, 0xe0 }, { 0xca, 0xe8 }, { 0xcb, 0xf0 },
	{ 0xcc, 0xd8 }, { 0xcd, 0x93 }, { 0xcd, 0x93 },

	{ OV9655_REG_TERM, OV9655_VAL_TERM }
};
const static struct ov9655_reg cif_yuv[] = { };
const static struct ov9655_reg vga_yuv[] = { };
const static struct ov9655_reg sxga_yuv[] = { };

/* 565 configs */
const static struct ov9655_reg qqcif_565[] = { };
const static struct ov9655_reg qqvga_565[] = { };
const static struct ov9655_reg qcif_565[] = { };
const static struct ov9655_reg qvga_565[] = {
	/* Value provided by Omnivision */
	{ 0x12, 0x80 }, { 0x00, 0x00 }, { 0x01, 0x80 },
	{ 0x02, 0x80 }, { 0x03, 0x02 }, { 0x04, 0x03 },
	{ 0x0e, 0x61 }, { 0x0f, 0x42 },
	{ 0x11, 0x01 }, { 0x12, 0x62 }, { 0x13, 0xe7 },
	{ 0x14, 0x3a }, { 0x16, 0x24 }, { 0x17, 0x18 },
	{ 0x18, 0x04 }, { 0x19, 0x01 }, { 0x1a, 0x81 },
	{ 0x1e, 0x04 }, { 0x24, 0x3c }, { 0x25, 0x36 },
	{ 0x26, 0x72 }, { 0x27, 0x08 }, { 0x28, 0x08 },
	{ 0x29, 0x15 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },
	{ 0x2c, 0x08 }, { 0x32, 0x24 }, { 0x33, 0x00 },
	{ 0x34, 0x3f }, { 0x35, 0x00 }, { 0x36, 0x3a },
	{ 0x38, 0x72 }, { 0x39, 0x57 }, { 0x3a, 0x80 },
	{ 0x3b, 0x04 }, { 0x3d, 0x99 }, { 0x3e, 0x0e },
	{ 0x3f, 0xc1 }, { 0x40, 0xc0 }, { 0x41, 0x01 },
	{ 0x42, 0xc0 }, { 0x43, 0x0a }, { 0x44, 0xf0 },
	{ 0x45, 0x46 }, { 0x46, 0x62 }, { 0x47, 0x2a },
	{ 0x48, 0x3c }, { 0x4a, 0xfc }, { 0x4b, 0xfc },
	{ 0x4c, 0x7f }, { 0x4d, 0x7f }, { 0x4e, 0x7f },

	{ 0x52, 0x28 }, { 0x53, 0x88 }, { 0x54, 0xb0 },
	{ 0x4f, 0x98 }, { 0x50, 0x98 }, { 0x51, 0x0 },
	{ 0x58, 0x1a },

	{ 0x59, 0x85 }, { 0x5a, 0xa9 }, { 0x5b, 0x64 },
	{ 0x5c, 0x84 }, { 0x5d, 0x53 }, { 0x5e, 0x0e },
	{ 0x5f, 0xf0 }, { 0x60, 0xf0 }, { 0x61, 0xf0 },
	{ 0x62, 0x00 }, { 0x63, 0x00 }, { 0x64, 0x02 },
	{ 0x65, 0x20 }, { 0x66, 0x00 }, { 0x69, 0x0a },
	{ 0x6b, 0x5a }, { 0x6c, 0x04 }, { 0x6d, 0x55 },
	{ 0x6e, 0x00 }, { 0x6f, 0x9d }, { 0x70, 0x21 },
	{ 0x71, 0x78 }, { 0x72, 0x11 }, { 0x73, 0x01 },
	{ 0x74, 0x10 }, { 0x75, 0x10 }, { 0x76, 0x01 },
	{ 0x77, 0x02 },

	{ 0x7a, 0x12 }, { 0x7b, 0x8 },  { 0x7c, 0x15 },
	{ 0x7d, 0x24 }, { 0x7e, 0x45 }, { 0x7f, 0x55 },
	{ 0x80, 0x6a }, { 0x81, 0x78 }, { 0x82, 0x87 },
	{ 0x83, 0x96 }, { 0x84, 0xa3 }, { 0x85, 0xb4 },
	{ 0x86, 0xc3 }, { 0x87, 0xd6 }, { 0x88, 0xe6 },
	{ 0x89, 0xf2 },

	{ 0x8a, 0x24 }, { 0x8c, 0x80 }, { 0x90, 0x7d },
	{ 0x91, 0x7b }, { 0x9d, 0x02 }, { 0x9e, 0x02 },
	{ 0x9f, 0x7a }, { 0xa0, 0x79 }, { 0xa1, 0x40 },
	{ 0xa4, 0x50 }, { 0xa5, 0x68 }, { 0xa6, 0x4a },
	{ 0xa8, 0xc1 }, { 0xa9, 0xef }, { 0xaa, 0x92 },
	{ 0xab, 0x04 }, { 0xac, 0x80 }, { 0xad, 0x80 },
	{ 0xae, 0x80 }, { 0xaf, 0x80 }, { 0xb2, 0xf2 },
	{ 0xb3, 0x20 }, { 0xb4, 0x20 }, { 0xb5, 0x00 },
	{ 0xb6, 0xaf }, { 0xbb, 0xae }, { 0xbc, 0x7f },
	{ 0xbd, 0x7f }, { 0xbe, 0x7f }, { 0xbf, 0x7f },
	{ 0xc0, 0xaa }, { 0xc1, 0xc0 }, { 0xc2, 0x01 },
	{ 0xc3, 0x4e }, { 0xc6, 0x05 }, { 0xc7, 0x81 },
	{ 0xc9, 0xe0 }, { 0xca, 0xe8 }, { 0xcb, 0xf0 },
	{ 0xcc, 0xd8 }, { 0xcd, 0x93 }, { 0xcd, 0x93 },

	{ 0x12, 0x03 }, { 0x3A, 0xC0 }, { 0x40, 0xd0 },
	{ 0xC7, 0x80 },

	{ OV9655_REG_TERM, OV9655_VAL_TERM }
};
const static struct ov9655_reg cif_565[] = { };
const static struct ov9655_reg vga_565[] = { };
const static struct ov9655_reg sxga_565[] = { };

/* 555 configs */
const static struct ov9655_reg qqcif_555[] = { };
const static struct ov9655_reg qqvga_555[] = { };
const static struct ov9655_reg qcif_555[] = { };
const static struct ov9655_reg qvga_555[] = { };
const static struct ov9655_reg cif_555[] = { };
const static struct ov9655_reg vga_555[] = { };
const static struct ov9655_reg sxga_555[] = { };

const static struct ov9655_reg *
	ov9655_reg_init[NUM_PIXEL_FORMATS][NUM_IMAGE_SIZES] =
{
 { qqcif_yuv, qqvga_yuv, qcif_yuv, qvga_yuv, cif_yuv, vga_yuv, sxga_yuv },
 { qqcif_565, qqvga_565, qcif_565, qvga_565, cif_565, vga_565, sxga_565 },
 { qqcif_555, qqvga_555, qcif_555, qvga_555, cif_555, vga_555, sxga_555 },
};
static struct i2c_driver ov9655_driver;

/*
 * Write a value to a register in an OV9655 sensor device.
 * Returns zero if successful, or non-zero otherwise.
 */
static int
ov9655_write_reg(struct i2c_client *client, u8 reg, u8 val)
{
	int err;
	struct i2c_msg msg[1];
	unsigned char data[2];

	if (!client->adapter)
		return -ENODEV;

	msg->addr = client->addr;
	msg->flags = 0;
	msg->len = 2;
	msg->buf = data;
	data[0] = reg;
	data[1] = val;
	err = i2c_transfer(client->adapter, msg, 1);
	if (err >= 0)
		return 0;
	return err;
}
/*
 * Read a value from a register in an OV9655 sensor device.
 * The value is returned in 'val'.
 * Returns zero if successful, or non-zero otherwise.
 */
static int
ov9655_read_reg(struct i2c_client *client, u8 reg, u8 *val)
{
	int err;
	struct i2c_msg msg[1];
	unsigned char data[1];

	if (!client->adapter)
		return -ENODEV;

	msg->addr = client->addr;
	msg->flags = 0;
	msg->len = 1;
	msg->buf = data;
	*data = reg;
	err = i2c_transfer(client->adapter, msg, 1);
	if (err >= 0) {
		msg->flags = I2C_M_RD;
		err = i2c_transfer(client->adapter, msg, 1);
	}
	if (err >= 0) {
		*val = *data;
		return 0;
	}
	return err;
}


/* fct use to initialize all the registers */
static int
ov9655_write_regs(struct ov9655 *is, const struct ov9655_reg reglist[])
{
	int err;
	const struct ov9655_reg *next = reglist;

	while (!((next->reg == OV9655_REG_TERM)
		&& (next->val == OV9655_VAL_TERM))) {
		err = ov9655_write_reg(&is->client, next->reg, next->val);
		udelay(100);
		if (err)
			return err;
		next++;
	}
	return 0;
}

#ifdef DEBUG
/* fct use to dump all the registers */
static int
ov9655_dump_regs(struct ov9655 *is, const struct ov9655_reg reglist[])
{
	int err;
	u8 val;
	const struct ov9655_reg *next = reglist;
	
	while (!((next->reg == OV9655_REG_TERM)
		&& (next->val == OV9655_VAL_TERM))) {
		err = ov9655_read_reg(&is->client, next->reg, &val);
		pr_debug("ov9655: dump reg:\nreg %x, value %x\n", next->reg, val);		
		udelay(100);
		if (err)
			return err;
		next++;
	}
	return 0;
}
#endif

/*
 * Find the best match for a requested image capture size.  The best match
 * is chosen as the nearest match that has the same number or fewer pixels
 * as the requested size, or the smallest image size if the requested size
 * has fewer pixels than the smallest image.
 */
static enum image_size
ov9655_find_size(unsigned int width, unsigned int height)
{
	enum image_size isize;
	unsigned long pixels = width*height;

	for (isize = QQCIF; isize < SXGA; isize++) {
		if (ov9655_sizes[isize + 1].height *
			ov9655_sizes[isize + 1].width > pixels)
			return isize;
	}
	return SXGA;
}


/*
 * Configure the OV9655 for a specified image size, pixel format, and frame
 * period.
 * Returns zero if successful, or non-zero otherwise.
 * The actual frame period is returned in fper.
 */
static int ov9655_configure(struct atmel_isi_camera *cam,
			   struct atmel_isi_format *fmt)
{
	struct ov9655 *is = to_ov9655(cam);	
	int err;
	enum pixel_format pfmt = YUV;
	enum image_size isize;

	switch (fmt->pix.pixelformat) {
	case V4L2_PIX_FMT_RGB565:
	case V4L2_PIX_FMT_RGB565X:
		pfmt = RGB565;
		break;
	case V4L2_PIX_FMT_RGB555:
	case V4L2_PIX_FMT_RGB555X:
		pfmt = RGB555;
		break;
	case V4L2_PIX_FMT_YUYV:
	case V4L2_PIX_FMT_UYVY:
	default:
		pfmt = YUV;
	}

	isize = ov9655_find_size(fmt->pix.width, fmt->pix.height);

	/* configure image size and pixel format */
	err = ov9655_write_regs(is, ov9655_reg_init[pfmt][isize]);
	if (err) {
		printk(KERN_DEBUG "ov9655 config failed\n");
		return err;
	}

	return 0;
}


static int ov9655_get_format(struct atmel_isi_camera *cam,
			   struct atmel_isi_format *fmt)
{
	//struct ov9655 *is = to_ov9655(cam);
	int err = 0;

	return err;
}

static int ov9655_set_format(struct atmel_isi_camera *cam,
			   struct atmel_isi_format *fmt)
{
	struct ov9655 *is = to_ov9655(cam);
	int err;

	mutex_lock(&is->mutex);

	err = ov9655_configure(&is->cam, fmt);
	if (err)
		goto out;

	pr_debug("%s: set_format %ux%u\n", cam->name,
		 fmt->pix.width, fmt->pix.height);

out:
	mutex_unlock(&is->mutex);
	return err;
}

static int ov9655_start_capture(struct atmel_isi_camera *cam, struct atmel_isi_format *fmt)
{
	struct ov9655 *is = to_ov9655(cam);
	int err = 0;

	mutex_lock(&is->mutex);

	/* Set the color bar test mode: to test wether the sensor is
	 * properly configure or not.
	 */
	/* err = ov9655_write_reg(&is->client, 0x8D, 0x10); */

	mutex_unlock(&is->mutex);
	return err;
}

static int ov9655_stop_capture(struct atmel_isi_camera *cam)
{
	struct ov9655 *is = to_ov9655(cam);

	mutex_lock(&is->mutex);

	/* Need to do something here? */

	mutex_unlock(&is->mutex);
	
	return 0;
}

static void ov9655_reset(struct ov9655 *is)
{
	int err;

	/* Reset Pin = COM7 bit 7*/
	err = ov9655_write_reg(&is->client, OV9655_COM7, 0x82);
	if (err)
		pr_debug("ov9655_reset failed\n");
}

static int ov9655_init_hardware(struct ov9655 *is)
{
	int err = 0;
	u8 midh, midl, pid;

	/* Try to identify the camera */
	if (ov9655_read_reg(&is->client, OV9655_MIDH, &midh))
		return -ENODEV;
	if (ov9655_read_reg(&is->client, OV9655_MIDL, &midl))
		return -ENODEV;
	if (ov9655_read_reg(&is->client, OV9655_PID, &pid))
		return -ENODEV;

	if ((midh != OV9655_MIDH_MAGIC)
		|| (midl != OV9655_MIDL_MAGIC)
		|| (pid != OV9655_PID_MAGIC))
		/*
		 * We didn't read the values we expected, so
		 * this must not be an OV9655.
		 */
		return -ENODEV;

	/* Default config is YUV?? */
	/*err =  ov9655_configure(&is->cam, NULL);
	if (err) {
		pr_debug("init config failed for ov9655\n");
		return err;
	}*/

	/* Hey, that was easy. */
	return err;
}


static int ov9655_detect_client(struct i2c_adapter *adapter,
			      int address, int kind)
{
	struct i2c_client *client;
	struct ov9655 *is;
	int err;

	pr_debug("ov9655: detecting client on address 0x%x\n", address);

	/* Check if the adapter supports the needed features */
	if (!i2c_check_functionality(adapter,
				     (I2C_FUNC_SMBUS_READ_BYTE_DATA
				      | I2C_FUNC_SMBUS_WRITE_BYTE_DATA
				      | I2C_FUNC_SMBUS_READ_WORD_DATA
				      | I2C_FUNC_SMBUS_WRITE_WORD_DATA)))
		return 0;

	is = kzalloc(sizeof(struct ov9655), GFP_KERNEL);
	if (!is)
		return -ENOMEM;

	client = &is->client;
	client->addr = address;
	client->adapter = adapter;
	client->driver = &ov9655_driver;
	strcpy(client->name, "ov9655");

	is->cam.name = client->name;
	is->cam.hsync_act_low = 1;
	is->cam.vsync_act_low = 0;
	is->cam.pclk_act_falling = 0;
	is->cam.has_emb_sync = 0/*need to be 1??*/;
	is->cam.get_format = ov9655_get_format;
	is->cam.set_format = ov9655_set_format;
	is->cam.start_capture = ov9655_start_capture;
	is->cam.stop_capture = ov9655_stop_capture;

	mutex_init(&is->mutex);

	is->mclk = clk_get(NULL, mclk_name);
	if (IS_ERR(is->mclk)) {
		err = PTR_ERR(is->mclk);
		goto err_clk;
	}
	clk_enable(is->mclk);

	err = i2c_attach_client(client);
	if (err)
		goto err_attach;

	i2c_set_clientdata(client, is);

	err = ov9655_init_hardware(is);
	if (err)
		goto err_init_hw;

	/* We're up and running. Notify the ISI driver */
	err = atmel_isi_register_camera(&is->cam);
	if (err)
		goto err_register;

	pr_debug("OV9655 Image Sensor at %s:0x%02x\n",
	       adapter->name, address);

	return 0;

err_register:
err_init_hw:
	ov9655_reset(is);
	i2c_detach_client(client);
err_attach:
	clk_disable(is->mclk);
	clk_put(is->mclk);
err_clk:
	kfree(is);
	return err;
}

static int ov9655_attach_adapter(struct i2c_adapter *adapter)
{
	int err;
	pr_debug("ov9655: starting probe for adapter %s (%u)\n",
		 adapter->name, adapter->id);

	err = i2c_probe(adapter, &addr_data, ov9655_detect_client);

	return err;
}

static int ov9655_detach_client(struct i2c_client *client)
{
	struct ov9655 *is = i2c_get_clientdata(client);
	int err;

	atmel_isi_unregister_camera(&is->cam);

	ov9655_reset(is);

	err = i2c_detach_client(client);
	if (err)
		return err;

	clk_disable(is->mclk);
	clk_put(is->mclk);
	kfree(is);

	return 0;
}

static struct i2c_driver ov9655_driver = {
	.driver = {
		.name	= "ov9655 I2C Codec",
		.owner = THIS_MODULE,
	},
	.id		= I2C_DRIVERID_OV9655,
	.attach_adapter	= &ov9655_attach_adapter,
	.detach_client	= &ov9655_detach_client,
	.command = NULL,
};


static struct clk *mclk;

static int __init ov9655_init(void)
{
	int err;
	
	/*
	 * Set up the master clock, if available. If clk_get() fails,
	 * this hopefully means that the board generates a suitable
	 * master clock some other way, which is fine by us.
	 *
	 * We need to do this before probing the i2c bus, as the
	 * camera won't ack any messages when it doesn't have a clock.
	 */

	mclk = clk_get(NULL, mclk_name);
	if (!IS_ERR(mclk)) {
		clk_enable(mclk);
		pr_debug("isi_clk enable\n");
	}
	else {
		mclk = NULL;
		pr_debug("no isi clock enable\n");
	}

	err = i2c_add_driver(&ov9655_driver);
	if (err) {
		pr_debug("Failed to register ov9655\n");
		return err;
	}
	return 0;
}
module_init(ov9655_init);

static void __exit ov9655_exit(void)
{
	if (mclk) {
		clk_disable(mclk);
		clk_put(mclk);
	}

	i2c_del_driver(&ov9655_driver);
}
module_exit(ov9655_exit);

MODULE_AUTHOR("Sedji Gaouaou <sedji.gaouaou@atmel.com>");
MODULE_DESCRIPTION("Omnivision ov955 Image Sensor driver");
MODULE_LICENSE("GPL");
